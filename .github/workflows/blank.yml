name: "Artifactory Generic OIDC Multi-Job"

on:
  workflow_dispatch:
  push:

env:
  OIDC_PROVIDER: 'manu-new'
  OIDC_AUDIENCE: 'newmanu'
  JF_URL: "https://hts2.jfrog.io"

permissions:
  contents: read
  id-token: write

jobs:
  publish-artifact:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 1: Set up JFrog CLI with OIDC
      - name: Set up JFrog CLI with OIDC
        id: jfrog_setup
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ env.JF_URL }}
        with:
          oidc-provider-name: ${{ env.OIDC_PROVIDER }}
          oidc-audience: ${{ env.OIDC_AUDIENCE }}

      # Step 2: Archive Terraform Module
      - name: Archive Terraform Module
        run: |
          MODULE_VERSION=${{ github.ref_name }}
          MODULE_NAME='vpc'
          MODULE_NAMESPACE='myorg'
          ZIP_FILE="${MODULE_NAME}-aws-${MODULE_VERSION}.zip"
          zip -r $ZIP_FILE . -x '*.git*'
          echo "ZIPPING complete. File: $ZIP_FILE"
          echo "MODULE_NAMESPACE=$MODULE_NAMESPACE" >> $GITHUB_ENV
          echo "MODULE_NAME=$MODULE_NAME" >> $GITHUB_ENV
          echo "MODULE_VERSION=$MODULE_VERSION" >> $GITHUB_ENV
          echo "ZIP_FILE=$ZIP_FILE" >> $GITHUB_ENV
          ls -la $ZIP_FILE

      # Step 3: Publish Terraform Module to Artifactory
      - name: Publish Terraform Module to Artifactory
        run: |
          jf rt u ${{ env.ZIP_FILE }} manu-terra-module/${{ env.MODULE_NAMESPACE }}/${{ env.MODULE_NAME }}/aws/${{ env.MODULE_VERSION }}/

      # Step 4: Publish Build Info
      - name: Publish Build Info
        run: |
          jf rt build-collect-env
          jf rt build-add-git
          jf rt build-publish

      # Step 5: Create a basic main.tf for testing module resolution
      - name: Create main.tf for testing
        run: |
          echo "Module URL: ${{ env.JF_URL }}/manu-terra-module__${{ env.MODULE_NAMESPACE }}/${{ env.MODULE_NAME }}/aws"
          cat <<EOF > main.tf
          module "module-name" {
            source  = "hts2.jfrog.io/manu-terra-module__${{ env.MODULE_NAMESPACE }}/${{ env.MODULE_NAME }}/aws"
          }
          EOF
          echo "Created main.tf:"
          cat main.tf

            # Step 6: Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.9.8

      # Step 7: Retrieve JFrog Access Token and Configure Terraform Authentication
      - name: Configure Terraform Authentication
        run: |
          echo "ðŸ” Requesting JFrog access token usable by Terraform registry..."

          # Verify CLI authentication
          jf rt ping || { echo "âŒ JFrog CLI not authenticated"; exit 1; }

          # Try to create a new short-lived access token
          TOKEN_JSON=$(jf access token-create --description "Terraform OIDC token" --expiry 600 --audience "jfrog-platform" 2>&1 || true)

          echo "ðŸ”¹ Raw token-create output:"
          echo "$TOKEN_JSON"

          # Try to extract the token from JSON or fallback plain text
          TOKEN=$(echo "$TOKEN_JSON" | grep -Eo '"access_token"\s*:\s*"[^"]+"' | head -1 | awk -F'"' '{print $4}')

          # Fallback: if CLI returned a plain token, take that
          if [ -z "$TOKEN" ]; then
            TOKEN=$(echo "$TOKEN_JSON" | grep -Eo 'eyJ[a-zA-Z0-9_\-]{10,}\.[a-zA-Z0-9_\-]{10,}\.[a-zA-Z0-9_\-]{10,}')
          fi

          if [ -z "$TOKEN" ]; then
            echo "âŒ Failed to extract access token from JFrog CLI output."
            exit 1
          fi

          echo "âœ… Token extracted successfully."
          echo "TF_TOKEN_HTS2_JFROG_IO=$TOKEN" >> $GITHUB_ENV
          echo "âœ… Terraform authentication configured for hts2.jfrog.io"


          echo "âœ… Received JFrog access token for registry use."
          echo "TF_TOKEN_HTS2_JFROG_IO=$TOKEN" >> $GITHUB_ENV




      # Step 8: Initialize and Validate Terraform
      - name: Terraform Init & Validate
        run: |
          terraform init -upgrade
          terraform validate

